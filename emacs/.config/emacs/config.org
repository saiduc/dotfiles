#+TITLE: Emacs Configuration
#+AUTHOR: Sai Pandian
#+EMAIL: saipandian97@gmail.com
#+STARTUP: content

* General
** Better Defaults
These are some minor tweaks to the default look and behaviour of Emacs
#+begin_src emacs-lisp
(use-package emacs
  :straight nil
  :init

  ;; start emacs in home folder
  (cd "~")

  ;; prevents random flickering sometimes
  (add-to-list 'default-frame-alist '(inhibit-double-buffering . t))

  ;; never just bury when running quit-window, always kill the buffer
  (defadvice quit-window (before quit-window-always-kill)
    (ad-set-arg 0 t))
  (ad-activate 'quit-window)

  ;; disable auto-save, auto-backup and lockfiles
  (setq make-backup-files nil)
  (setq auto-save-default nil)
  (setq create-lockfiles nil)

  ;; turn off annoying Emacs splash screen
  (setq inhibit-splash-screen t)

  ;; disable some warnings when compiling init file
  (setq warning-minimum-level :error)

  ;; allow y-or-n instead of yes-or-no
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; always follow symbolic links
  (setq vc-follow-symlinks t)

  ;; scroll properly, not stupid emacs way
  (setq scroll-conservatively 101)
  (setq mouse-wheel-scroll-amount '(1))
  (setq mouse-wheel-progressive-speed nil)
  (pixel-scroll-precision-mode 1)

  ;; refresh buffers if they are changed outside of emacs
  (global-auto-revert-mode 1)

  ;; highlight current line
  (global-hl-line-mode 1)

  ;; turn off bell
  (setq ring-bell-function 'ignore)

  ;; create eshell alias for find-file function
  (defalias 'ff 'find-file)

  ;; enable emacs server
  (server-mode 1)

  ;; turn off indicator for wrapping text
  (setf (cdr (assq 'continuation fringe-indicator-alist))
	'(nil nil))
  
  ;; disable *Messages* buffer that is present on startup
  (setq-default message-log-max nil)
  (kill-buffer "*Messages*")

  ;; set default wrap length
  (setq-default fill-column 80))
#+end_src

** No Littering
This package stops packages from cluttering the Emacs folder with random files
#+begin_src emacs-lisp
(use-package no-littering
  :straight t)
#+end_src

** Dired
This makes dired work as expected
#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :defer t
  :config
  (put 'dired-find-alternate-file 'disabled nil))
#+end_src

* User Interface
** Diminish
Diminish allows the hiding of minor modes in modeline
#+begin_src emacs-lisp
(use-package diminish
  :straight t
  :defer t)
#+end_src

** Themes
A nice collection of themes
#+begin_src emacs-lisp
(use-package doom-themes
  :straight t
  :defer t
  :init
  (load-theme 'doom-dracula t))
#+end_src

** Solaire Mode
Makes themes look better
#+begin_src emacs-lisp
(use-package solaire-mode
  :straight t
  :config
  (solaire-global-mode 1))
#+end_src

** Mode Line
I use doom modeline since it is lightweight and pretty
#+begin_src emacs-lisp
(use-package doom-modeline
  :straight t
  :diminish
  :init
  ;; (set-face-attribute 'mode-line nil
  ;; 		      :background "#353644"
  ;; 		      :foreground "white"
  ;; 		      :overline nil
  ;; 		      :underline nil)
  (setq doom-modeline-height 10)
  (setq doom-modeline-bar-width 1)
  (setq doom-modeline-icon nil)
  (setq doom-modeline-minor-modes t)
  (setq doom-modeline-persp-name nil)
  (setq doom-modeline-lsp t)
  (setq doom-modeline-env-version nil)
  (setq inhibit-compacting-font-caches t)
  (setq doom-modeline-buffer-encoding nil)
  :config
  (doom-modeline-mode 1))
#+end_src

** Dashboard
This gives a nice startup page when Emacs first runs
#+begin_src emacs-lisp
(use-package dashboard
  :straight t
  :diminish page-break-lines-mode
  :init
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  (setq dashboard-startup-banner 'logo)
  ;; (setq dashboard-banner-logo-title "It is only with the heart that one can see rightly; what is essential is invisible to the eye.")
  ;; (setq dashboard-banner-logo-title "Everything will be okay in the end; if it's not okay, it's not the end")
  (setq dashboard-banner-logo-title "Sorry I didn't save the world, my friend; I was too busy building mine again")
  (setq dashboard-footer-messages '("Sai Pandian"))
  (setq dashboard-set-init-info nil)
  (setq dashboard-items '((recents  . 25)))
  (setq dashboard-set-heading-icons nil)
  (setq dashboard-set-file-icons nil)
  (setq dashboard-center-content t)
  :hook (dashboard-mode . (lambda () (diminish 'page-break-lines-mode)))
  :config
  (dashboard-setup-startup-hook))
#+end_src

** Vertico Completion
Vertico is a good replacement for helm
#+begin_src emacs-lisp
(use-package vertico
  :straight t
  :defer 0.01
  :init
  (setq vertico-cycle t)
  (setq vertico-resize nil)
  (setq enable-recursive-minibuffers t)
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)
  (setq completion-auto-help nil)
  :bind
  (("C-x C-b" . switch-to-buffer)
   ("C-x C-k" . kill-buffer)
   (:map vertico-map
	("C-j" . vertico-next)
	("C-k" . vertico-previous)
	:map minibuffer-local-map
	("C-h" . backward-kill-word)))
  :config
  (savehist-mode 1)
  (vertico-mode 1))
#+end_src

Make vertico behave like ido in find-file (with return to enter folders)
#+begin_src emacs-lisp
(use-package vertico-directory
  :straight nil
  :load-path "straight/build/vertico/extensions"
  :defer t
  :after vertico
  :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))
#+end_src

More information in Vertico buffers
#+begin_src emacs-lisp
(use-package marginalia
  :straight t
  :after vertico
  :init
  (setq marginalia-align 'right)
  (setq marginalia-max-relative-age 0)
  :config
  (marginalia-mode))
#+end_src

Allow spaces in vertico completion
#+begin_src emacs-lisp
(use-package orderless
  :straight t
  :after vertico
  :config
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

** Perspective Mode
I use this for managing workspaces inside Emacs
#+begin_src emacs-lisp
(use-package perspective
  :straight t
  :defer 0.01
  :bind
  (("C-x C-i" . persp-ibuffer)
   ("C-x x h" . persp-prev)
   ("C-x x l" . persp-next)
   ("C-x x s" . persp-switch)
   ("C-x x i" . persp-import)
   ("C-x x r" . persp-rename)
   ("C-x x C-l" . persp-state-load)
   ("C-x x C-s" . persp-state-save))
  :init
  ;; (custom-set-faces '(persp-selected-face ((t (:foreground "#FD7CC5")))))
  :config
  (use-package ibuffer :straight (:type built-in))
  (persp-mode 1))
#+end_src

* Key Bindings
** Evil
I am an ex-vim user so I use evil for my editing
#+begin_src emacs-lisp
(use-package evil
  :straight t
  :defer 0.01
  :init
  (setq evil-want-integration t) ;; This is optional since it's already set to t by default.
  (setq evil-want-keybinding nil)
  (setq evil-insert-state-message nil)
  (setq evil-visual-state-message nil)
  (setq evil-mode-line-format '(before . mode-line-front-space))
  (setq evil-normal-state-tag "NORMAL")
  (setq evil-insert-state-tag "INSERT")
  (setq evil-visual-state-tag "VISUAL")
  (setq evil-operator-state-tag "OPERATOR")
  (setq evil-motion-state-tag "MOTION")
  (setq evil-emacs-state-tag "EMACS")
  (setq evil-want-C-i-jump nil)
  (define-key key-translation-map (kbd "ESC") (kbd "C-g")) ;; make esc all-powerful
  :bind (("C-c h" . evil-window-left)
	     ("C-c j" . evil-window-down)
	     ("C-c k" . evil-window-up)
	     ("C-c l" . evil-window-right)
	     ("C-c H" . evil-window-move-far-left)
	     ("C-c J" . evil-window-move-very-bottom)
	     ("C-c K" . evil-window-move-very-top)
	     ("C-c L" . evil-window-move-far-right)
	     ("M-p"   . (lambda () (interactive) (yank-pop)))
	     (:map evil-insert-state-map ("C-k" . nil)))
  :config
  (evil-set-undo-system 'undo-redo)
  (evil-mode 1))
#+end_src

Evil collection fixes evil-mode in a lot of places
#+begin_src emacs-lisp
(use-package evil-collection
  :straight t
  :after evil
  :diminish evil-collection-unimpaired-mode
  :config
  (evil-collection-init)
  ;; need to refresh dashboard so evil bindings work in it
  (dashboard-refresh-buffer))
#+end_src

Port of vim commentary plugin
#+begin_src emacs-lisp
(use-package evil-commentary
  :straight t
  :after evil
  :diminish
  :config
  (evil-commentary-mode 1))
#+end_src

Port of vim surround plugin
#+begin_src emacs-lisp
(use-package evil-surround
  :straight t
  :after evil
  :config
  (global-evil-surround-mode 1))
#+end_src

** General
#+begin_src emacs-lisp
(use-package general
  :straight t
  :defer 0.01
  :config
  (general-override-mode))
#+end_src

** Which Key
Which key is useful for discoverability
#+begin_src emacs-lisp
(use-package which-key
  :straight t
  :defer 0.01
  :diminish
  :init
  (setq which-key-idle-delay 1)
  (setq which-key-idle-secondary-delay 0)
  :config
  (which-key-mode))
#+end_src

* Shells
** Exec Path From Shell
This simply gets the shell variable and path from default shell
#+begin_src emacs-lisp
(when (memq window-system '(mac ns x))
  (use-package exec-path-from-shell
    :straight t
    :defer 0.01
    :init
    (setq exec-path-from-shell-check-startup-files nil)
    :config
    (exec-path-from-shell-initialize)))
#+end_src

** Terminals
I use vterm as my terminal because it is a lot better than ansi-term. You will
need to have some dependencies installed for this, which can be done in mac with: 
brew install cmake libtool libvterm
#+begin_src emacs-lisp
(use-package vterm
  :straight t
  :defer t)
#+end_src

Multi-Vterm lets me manage multiple vterm buffers easily
#+begin_src emacs-lisp
(use-package multi-vterm
  :straight t
  :defer t
  :init
  (setq multi-vterm-buffer-name "vterm")
  :bind (("C-c t t" . multi-vterm)
	   ("C-c t e" . eshell)))
#+end_src

* Writing & Org
** Org Mode
I use org mode extensively so this is quite a long section...
#+begin_src emacs-lisp
(use-package org
  :straight t
  :defer t
  :diminish auto-fill-function visual-line-mode
  :hook ((org-mode . auto-fill-mode)
         (org-mode . visual-line-mode)
         (org-mode . display-line-numbers-mode)
	     (org-mode . show-paren-mode)
	     (org-mode . (lambda () (diminish 'org-indent-mode)))
	     (org-mode . electric-pair-mode)
	     (org-mode . (lambda ()
	                   (setq-local electric-pair-inhibit-predicate
	          		       `(lambda (c)
	          			  (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))))))
  
  :bind (("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("C-c f" . my/list-org-files))
  
  :init

  ;; agenda files, refile targets and drawer targets
  (setq org-agenda-files (apply 'append
				(list
			         (directory-files-recursively "~/Dropbox/Org/Personal" "\\.org$")
				 (directory-files-recursively "~/Dropbox/Org/Work" "\\.org$")
				 '("~/Dropbox/Org/Inbox.org"))))
  (setq org-refile-targets '((org-agenda-files :maxlevel . 1)))
  (setq org-log-into-drawer "LOGBOOK")

  ;; make custom function that refreshes org files
  (defun my/refresh-org-files ()
    (interactive)
    (setq org-agenda-files (apply 'append
				  (list
			           (directory-files-recursively "~/Dropbox/Org/Personal" "\\.org$")
				   (directory-files-recursively "~/Dropbox/Org/Work" "\\.org$")
				   '("~/Dropbox/Org/Inbox.org"))))
    (setq org-refile-targets '((org-agenda-files :maxlevel . 1))))

  ;; make custom function to list all org files 
  (defun my/list-org-files ()
    (interactive)
    (project-switch-project "~/Dropbox/Org"))

  ;; some general settings
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-use-outline-path 'file)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-hide-leading-stars nil)
  (setq org-startup-indented t)
  (setq org-hide-emphasis-markers t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-fontify-natively t)
  (setq org-edit-src-content-indentation 0)
  (setq org-src-tab-acts-natively t)
  (setq org-agenda-default-appointment-duration 30)
  (setq org-log-done 'time)
  (setq org-ellipsis " ⌄")
  (setq org-export-with-smart-quotes t)

  (setq org-todo-keywords
        '((sequence "TODO" "WAIT" "SOMEDAY" "|" "DONE" "CANCELLED")))

  :config

  ;; better looking org-agenda
  (setq org-agenda-custom-commands
	'(("n" "Custom agenda view"
	   (
	    (agenda)
	    (todo "TODO")
	    (todo "WAIT")
	    (todo "SOMEDAY")
	    ))))
  (setq org-agenda-prefix-format
	(quote
	 ((agenda . "%-20c%?-13t% s")
          (timeline . "% s")
          (todo . "%-20:c ")
          (tags . "%-20c")
          (search . "%-20c"))))

  ;; evil bindings for org-agenda
  (eval-after-load 'org-agenda
    '(progn
       (evil-set-initial-state 'org-agenda-mode 'normal)
       (evil-define-key 'normal org-agenda-mode-map
	 (kbd "<RET>") 'org-agenda-switch-to
	 (kbd "\t") 'org-agenda-goto
	 "q" 'org-agenda-quit
	 "r" 'org-agenda-redo
	 "gr" 'org-agenda-redo
	 "f" 'org-agenda-later
	 "b" 'org-agenda-earlier
	 )))

  ;; org babel stuff
  (org-babel-do-load-languages 
   'org-babel-load-languages 
   '((emacs-lisp . t)
     (python     . t)))

  ;; hook goes here since org-babel-after-execute-hook is not available prior to loading org mode package
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)

  (add-to-list 'org-modules 'org-tempo t)
  (add-to-list 'org-modules 'org-habit t))
#+end_src

** Org Superstar
This enables nice looking icons in org-headings
#+begin_src emacs-lisp
(use-package org-superstar
  :straight t
  :defer t
  :init
  (setq org-superstar-configure-like-org-bullets t)
  :hook (org-mode . org-superstar-mode))
#+end_src

** Org Capture Templates
Some capture templates that suit my workflow
#+begin_src emacs-lisp
(setq org-capture-templates
      '(
	
	("t" "Task" entry (file+headline "~/Dropbox/Org/Inbox.org" "Tasks")
	 "** TODO %?" :kill-buffer t)
	
	("e" "Event" entry (file+headline "~/Dropbox/Org/Inbox.org" "Events")
	 "** %?\n%^T" :kill-buffer t)
	
	("n" "Note" entry (file+headline "~/Dropbox/Org/Inbox.org" "Notes")
	 "** %?" :kill-buffer t)
	
	))
#+end_src

** Flyspell
On the go spell-checking in Emacs You will need to install aspell on your system
for this to work. On MacOS: brew install aspell
#+begin_src emacs-lisp
(use-package flyspell
  :straight (:type built-in)
  :defer t
  :diminish flyspell-mode
  :init
  (setq ispell-program-name "/usr/bin/aspell")
  (setq ispell-dictionary "british"))
#+end_src

** PDF Tools
This lets me view PDFs in Emacs (better than simply with doc-view)
#+begin_src emacs-lisp
(use-package pdf-tools
  :straight t
  :defer t
  ;; :pin manual ;; don't reinstall when package updates
  :mode  ("\\.pdf\\'" . pdf-view-mode)
  :bind (:map pdf-view-mode-map ("C-s" . isearch-forward))
  :init
  (setq-default pdf-view-display-size 'fit-page)
  (setq mouse-wheel-follow-mouse t)
  (setq pdf-view-midnight-colors '("#ffffff" . "#000000"))
  :config
  (pdf-tools-install :no-query)
  (require 'pdf-occur))
#+end_src

* Programming
** General
Some general hooks and settings for programming
#+begin_src emacs-lisp
(use-package prog-mode
  :straight (:type built-in)
  :defer t
  :hook ((prog-mode . display-fill-column-indicator-mode)
	     (prog-mode . display-line-numbers-mode)
	     (prog-mode . hs-minor-mode)
	     (prog-mode . show-paren-mode)
	     (prog-mode . electric-pair-mode)
	     (prog-mode . (lambda () (diminish 'hs-minor-mode)))))
#+end_src

** Magit
Magit is a wonderful git frontend for emacs
#+begin_src emacs-lisp
(use-package magit
  :straight t
  :defer t
  :bind ("C-x g" . magit-status)
  :init
  ;; add some code to auto kill magit diff buffers after committing
  (defun kill-magit-diff-buffer-in-current-repo (&rest _)
    "Delete the magit-diff buffer related to the current repo"
    (let ((magit-diff-buffer-in-current-repo
           (magit-mode-get-buffer 'magit-diff-mode)))
      (kill-buffer magit-diff-buffer-in-current-repo)))
  :hook (git-commit-setup . (lambda () (add-hook 'with-editor-post-finish-hook
						 #'kill-magit-diff-buffer-in-current-repo
						 nil t))))
#+end_src

** Treesitter
I use treesitter for syntax highlighting
#+begin_src emacs-lisp
(use-package tree-sitter
  :defer t
  :straight t
  :diminish
  :hook (python-mode . tree-sitter-hl-mode)
  :config
  (use-package tree-sitter-langs :straight t))
#+end_src

** Auto-Completion
I use corfu for all my autocompletion needs
#+begin_src emacs-lisp
(use-package corfu
  :straight t
  :defer t
  :diminish
  :init
  (setq corfu-cycle t)
  (setq corfu-auto t)
  (setq corfu-quit-no-match t)
  (setq corfu-quit-at-boundary t)
  (setq corfu-preselect-first nil)
  (setq tab-always-indent t)
  (setq corfu-auto-delay 0)
  (setq corfu-auto-prefix 1)
  (setq corfu-bar-width 0)
  (setq lsp-completion-provider :none)
  (defun corfu-lsp-setup ()
    (setq-local completion-styles '(orderless)
		completion-category-defaults nil))
  :hook ((prog-mode . corfu-mode)
	     (tex-mode  . corfu-mode)
	     (org-mode  . corfu-mode)
	     (lsp-completion-mode . corfu-lsp-setup))
  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous)
	    ("C-j" . corfu-next)
	    ("C-k" . corfu-previous)))
#+end_src

** Syntax Checking
I am replacing flycheck with the built-in flymake
#+begin_src emacs-lisp
(use-package flymake
  :straight (:type built-in)
  :defer t
  :diminish flymake-mode
  :init
  (setq flymake-start-on-flymake-mode t)
  (setq flymake-no-changes-timeout 1)
  :config
  (general-define-key
   :keymaps 'prog-mode-map
   :prefix lsp-keymap-prefix
   "e" '(:ignore t :which-key "errors")
   "en" '(flymake-goto-next-error :which-key "next error")
   "ep" '(flymake-goto-prev-error :which-key "previous error")
   "el" '(flymake-show-buffer-diagnostics :which-key "list all errors")
   "et" '(flymake-mode :which-key "toggle linting")
   "eb" '(flymake-running-backends :which-key "list running backends")))
#+end_src

** Neotree
Provides tree view
#+begin_src emacs-lisp
(use-package neotree
  :straight t
  :defer t
  :bind ("C-x t" . neotree-toggle)
  :init
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
  (setq neo-show-hidden-files t)
  :config
  (general-define-key
   :keymaps '(prog-mode-map neotree-mode-map)
   :prefix lsp-keymap-prefix
   "t" '(:ignore t :which-key "tree")
   "tt" '(neotree-toggle :which-key "toggle filetree")
   "td" '(neotree-dir :which-key "change tree root directory")
   "tr" '(neotree-refresh :which-key "refresh filetree")))
#+end_src

** LSP Mode
Language servers handle most of my languages
#+begin_src emacs-lisp
(use-package lsp-mode
  :straight t
  :defer t
  :diminish lsp-mode
  :hook (lsp-mode . lsp-enable-which-key-integration)
  :commands (lsp lsp-deferred)
  :init
  (setq lsp-keymap-prefix "C-l")
  (setq lsp-modeline-diagnostics-enable nil)
  (setq lsp-prefer-flymake t)
  (setq lsp-signature-auto-activate t)
  (setq lsp-signature-doc-lines 1)
  (setq lsp-signature-render-documentation nil)
  (setq read-process-output-max (* 1024 1024))
  (setq lsp-headerline-breadcrumb-icons-enable nil)
  :bind (:map lsp-mode-map (("M-]" . lsp-find-definition)
			        ("M-[" . xref-pop-marker-stack))))
#+end_src

** Highlight Indent Guides
This displays indent guides
#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :straight t
  :diminish
  :defer t
  :init
  (setq highlight-indent-guides-method 'bitmap)
  :hook (prog-mode . highlight-indent-guides-mode))
#+end_src

** Apheleia
I use this to format code (when the lsp-server can't do it by itself)
#+begin_src emacs-lisp
(use-package apheleia
  :straight (:host github :repo "raxod502/apheleia")
  :defer t
  :hook (python-mode . (lambda () (general-define-key
				   :keymaps 'python-mode-map
				   :prefix lsp-keymap-prefix
				   "=" '(:ignore t :which-key "formatting")
				   "==" '(apheleia-format-buffer :which-key "format buffer")))))
#+end_src

** Python
I use the pyright server for Python which needs npm installed
To use dap mode with python, you need to run: pip install debugpy 
#+begin_src emacs-lisp
(use-package lsp-pyright
  :straight t
  :defer t
  :diminish eldoc-mode
  :hook (python-mode . lsp-deferred)
  :config
  (add-hook 'conda-postactivate-hook (lambda () (lsp-restart-workspace)))
  (add-hook 'conda-postdeactivate-hook (lambda () (lsp-restart-workspace))))
#+end_src

Conda handles switching virtual environments
#+BEGIN_SRC emacs-lisp
(use-package conda
  :straight t
  :defer t
  :init
  (setq conda-anaconda-home (expand-file-name "~/miniconda3"))
  (setq conda-env-home-directory (expand-file-name "~/miniconda3"))
  :config
  (conda-env-initialize-interactive-shells)
  (conda-env-initialize-eshell))
#+END_SRC

Turn off annoying python start message
#+begin_src emacs-lisp
(setq python-indent-guess-indent-offset-verbose nil)
#+end_src

Get nice sphinx doc generation
#+begin_src emacs-lisp
(use-package sphinx-doc
  :straight t
  :defer t
  :diminish sphinx-doc-mode
  :hook (python-mode . sphinx-doc-mode))
#+end_src

** Emacs IPython Notebook
Jupyter notebook support in Emacs. For dataframes, do:
pd.set_option('expand_frame_repr', False)
#+begin_src emacs-lisp
(use-package ein-notebook
  :straight (ein :type git :host github :repo "millejoh/emacs-ipython-notebook" :build (:not native-compile))
  :defer t
  ;; disable fill column and auto-complete
  :hook ((ein:ipynb-mode . (lambda ()
			       (display-fill-column-indicator-mode -1)
			       (corfu-mode -1)
			       (solaire-mode -1)))
	     (poly-ein-mode .  (lambda ()
			       (display-fill-column-indicator-mode -1)
			       (corfu-mode -1)
			       (solaire-mode -1))))
  :init
  (setq ein:worksheet-enable-undo t) ;; enable undoing inside cells
  (setq ein:output-area-inlined-images t) ;; allow inline images
  (setq ein:markdown-header-scaling t) ;; disable different sized headings
  (setq ein:markdown-enable-math t) ;; allow latex math in markdown cells
  (custom-set-faces  ;; make background of cells darker and change font colour
   '(ein-codecell-input-area-face ((t (:foreground "#23242f"))))
   '(ein:codecell-input-area-face ((t (:extend t :background "#23242f"))))
   '(ein-markdowncell-input-area-face ((t (:foreground "#23242f"))))
   '(ein:markdowncell-input-area-face ((t (:extend t :background "#23242f")))))
  
  ;; suppress all warnings
  (setq warning-suppress-log-types '((ein) (ein)))
  (setq warning-suppress-types '((ein)))

  ;; evil keybindings
  :bind (:map ein:notebook-mode-map
	      (("M-d" . ein:worksheet-kill-cell-km)
	       ("M-y" . ein:worksheet-copy-cell-km)
           ("M-p" . ein:worksheet-yank-cell-km)
           ("M-d" . ein:worksheet-kill-cell-km)
           ("M-o" . ein:worksheet-insert-cell-below-km)
           ("M-O" . ein:worksheet-insert-cell-above-km)
           ("C-j" . ein:worksheet-goto-next-input-km)
           ("C-k" . ein:worksheet-goto-prev-input-km)
           ("M-h" . ein:notebook-worksheet-move-prev-km)
           ("M-j" . ein:worksheet-move-cell-down-km)
           ("M-k" . ein:worksheet-move-cell-up-km)
           ("M-l" . ein:notebook-worksheet-move-next-km)
	       ("M-t" . ein:worksheet-toggle-output-km)
	       ("C-c x" . ein:worksheet-clear-output-km)
	       ("C-c X" . ein:worksheet-clear-all-output-km)
	       ("C-o" . ein:console-open-km)
	       ("M-s" . ein:worksheet-split-cell-at-point-km)
	       ("M-u" . ein:worksheet-toggle-cell-type-km)
	       ("C-c q" . ein:notebook-kernel-interrupt-command)
	       ("C-<return>" . ein:worksheet-execute-cell-km)
	       ("S-<return>" . ein:worksheet-execute-cell-and-goto-next-km))))
#+end_src

** LaTeX
I use the TexLab language server for LaTeX
Install using: brew install texlab
#+begin_src emacs-lisp
(use-package lsp-latex
  :straight t
  :defer t
  :hook ((tex-mode . lsp-deferred)
	   (tex-mode . (lambda () (require 'lsp-latex)))
	   (latex-mode . lsp-deferred)
	   (bibtex-mode . lsp-deferred)
	   (latex-mode . (lambda () 
			 (define-key tex-mode-map (kbd "C-c C-c") 'my/latex-build)
			 (define-key tex-mode-map (kbd "C-c C-v") 'my/open-pdf)))
	   (latex-mode . auto-fill-mode)
	   (latex-mode . visual-line-mode)
	   (latex-mode . display-fill-column-indicator-mode)
	   (latex-mode . display-line-numbers-mode)
	   (bibtex-mode . display-line-numbers-mode))
  :init
  (setq lsp-latex-lint-on-change t)
  (setq lsp-latex-lint-on-save t)

  ;; function to open pdf associated with tex file
  (defun my/open-pdf ()
    (interactive)
    (buffer-file-name (other-buffer))
    ;; can do find-file instead of browse-url to open inside emacs
    (browse-url (replace-regexp-in-string ".tex" ".pdf" buffer-file-name)))
  
  ;; function to save and build latex file
  (defun my/latex-build ()
    (interactive)
    (save-buffer)
    (lsp-latex-build)))
#+end_src

** C/C++
I use the clangd server for C++.
Install using: brew install llvm
Make sure llvm is on your path.
#+begin_src emacs-lisp
(use-package cc-mode
  :straight (:type built-in)
  :defer t
  :hook (c++-mode . lsp-deferred)
  :init
  (setq c-default-style "linux"))
#+end_src
